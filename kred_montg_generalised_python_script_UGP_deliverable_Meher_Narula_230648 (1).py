# -*- coding: utf-8 -*-
"""Kred_montg_generalised.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1noxWmpGjpRpHpBNMTPf-3jjECccShzd8
"""

#!/usr/bin/env python3
"""
Robust KRED/Montgomery Verilog generator.

- Modes: "binary" or "csd" (NAF/CSD exact)
- Safe accumulator widths and canonicalization
- Optional precomputed t = a*b inlined for test vectors
- Emits module kred_montgomery.v
"""

import math

# -------------------------
# NAF (exact CSD) decomposition
# returns list of (shift, +1/-1)
# -------------------------
def naf_decompose(n: int):
    if n == 0:
        return []
    terms = []
    k = n
    i = 0
    while k:
        if k & 1:
            # choose digit
            if (k & 3) == 1:
                zi = 1
            else:
                zi = -1
            terms.append((i, zi))
            k = k - zi
        else:
            # zero digit
            pass
        k >>= 1
        i += 1
    return terms


def csd_groups_from_naf(naf_terms):
    pos = [s for (s, d) in naf_terms if d == 1]
    neg = [s for (s, d) in naf_terms if d == -1]
    pos.sort()
    neg.sort()
    return pos, neg


# -------------------------
# Binary groups: exact bits
# returns lists of positions where bit == 1
# -------------------------
def binary_groups(n: int):
    pos = []
    i = 0
    k = n
    while k:
        if k & 1:
            pos.append(i)
        k >>= 1
        i += 1
    return sorted(pos)


# -------------------------
# Build a shift-sum string given shifts list
# varname is used directly in string (t_ext, m_ext, etc.)
# acc_pad is a string like "TD_ACC-T_BITS" or numeric inlined
# The function returns a Verilog expression string (no surrounding semicolon)
# -------------------------
def build_pos_expr(varname: str, shifts: list, acc_pad: str, var_width_name: str):
    """
    Build safe Verilog shift-add expression for 'varname' using the shifts list.
    - acc_pad: string to put where the accumulator pad expression goes (e.g. "TD_ACC")
    - var_width_name: string for the var width identifier (e.g. "T_BITS" or "WIDTH")
    Returns a Verilog expression string (no trailing semicolon).
    Example output for one term: "({{(TD_ACC-T_BITS){1'b0}}, t_reg} << 5)"
    """
    if not shifts:
        return "0"

    terms = []
    # Build the replication/zero vector string once
    # This creates the text like: "{(TD_ACC-T_BITS){1'b0}}"
    zeros_template = "{" + "(" + acc_pad + "-" + var_width_name + ")" + "{1'b0}" + "}"

    for s in shifts:
        # Build the concatenation { zeros, varname } as a plain string
        concat = "{" + zeros_template + ", " + varname + "}"
        if s == 0:
            # zero shift: just the concatenation
            term = concat
        else:
            # shifted term: ( {zeros, var} << s )
            term = "(" + concat + " << " + str(s) + ")"
        terms.append(term)

    # join with " + " (Verilog addition)
    return " + ".join(terms)

# -------------------------
# Generate Verilog
# mode: "binary" or "csd"
# -------------------------
def generate_verilog(q: int, mode="csd", a_const=None, b_const=None, out_filename="kred_montgomery_{5}.v"):
    # compute widths
    q_bits = q.bit_length()
    WIDTH = q_bits
    R = 1 << WIDTH

    # montgomery q'
    q_inv = pow(q, -1, R)
    q_prime = (-q_inv) % R
    R_mod_q = R % q

    # safe widths (conservative)
    T_BITS = q_bits * 2 + 4
    T_D_BITS = T_BITS + WIDTH + 16
    MULT_BITS = T_BITS + q_bits + 16
    SUM_BITS = max(T_BITS, MULT_BITS) + 16
    U_BITS = SUM_BITS - WIDTH + 16

    # get pos/neg groups per mode
    if mode == "csd":
        qp_terms = naf_decompose(q_prime)
        qp_pos, qp_neg = csd_groups_from_naf(qp_terms)
        q_terms = naf_decompose(q)
        q_pos, q_neg = csd_groups_from_naf(q_terms)
    elif mode == "binary":
        qp_pos = binary_groups(q_prime)
        qp_neg = []
        q_pos = binary_groups(q)
        q_neg = []
    else:
        raise ValueError("mode must be 'csd' or 'binary'")

    # start building lines
    lines = []
    lines.append("// Auto-generated KRED/Montgomery")
    lines.append("// q = {}".format(q))
    lines.append("// R = 2^{} = {}".format(WIDTH, R))
    lines.append("// q' = {}".format(q_prime))
    lines.append("// mode = {}".format(mode))
    lines.append("")
    lines.append("`timescale 1ns / 1ps")
    lines.append("")
    lines.append("module kred_montgomery #(")
    lines.append(f"  parameter [{q_bits-1}:0] Q = {q}")
    lines.append("  parameter WIDTH = {}".format(WIDTH))
    lines.append(") (")
    lines.append("  input  wire clk,")
    lines.append("  input  wire rst,")
    lines.append("  input  wire start,")
    lines.append("  input  wire [{}:0] a,".format(WIDTH-1))
    lines.append("  input  wire [{}:0] b,".format(WIDTH-1))
    lines.append("  output reg  [{}:0] result,".format(WIDTH-1))
    lines.append("  output reg  done")
    lines.append(");")
    lines.append("")
    lines.append("  // local widths")
    lines.append("  localparam integer Q_BITS = {};".format(q_bits))
    lines.append("  localparam integer T_BITS = {};".format(T_BITS))
    lines.append("  localparam integer T_D_BITS = {};".format(T_D_BITS))
    lines.append("  localparam integer MULT_BITS = {};".format(MULT_BITS))
    lines.append("  localparam integer SUM_BITS = {};".format(SUM_BITS))
    lines.append("  localparam integer U_BITS = {};".format(U_BITS))
    lines.append("")

    # t_reg precompute or sequential
    if (a_const is not None) and (b_const is not None):
        t_val = a_const * b_const
        lines.append("  // precomputed t = a*b")
        lines.append("  wire [T_BITS-1:0] t_reg = {}'d{};".format(T_BITS, t_val))
    else:
        lines.append("  // sequential multiplier (shift-add)")
        lines.append("  reg  [T_BITS-1:0] mul_acc;")
        lines.append("  reg  [T_BITS-1:0] t_reg;")
        lines.append("  reg  [7:0] idx;")
    lines.append("")

    # t_ext
    lines.append("  // extend")
    lines.append("  wire [T_D_BITS-1:0] t_ext = {{(T_D_BITS-T_BITS){{1'b0}}}, t_reg};")
    lines.append("")

    # t_qprime pos/neg
    lines.append("  // t * q' using {} decomposition".format(mode))
    lines.append("  localparam integer TD_ACC = T_D_BITS + 32;")
    pos_expr = build_pos_expr("t_reg", qp_pos, "TD_ACC", "T_BITS")
    neg_expr = build_pos_expr("t_reg", qp_neg, "TD_ACC", "T_BITS")
    lines.append("  wire [TD_ACC-1:0] t_qprime_pos = {};".format(pos_expr))
    lines.append("  wire [TD_ACC-1:0] t_qprime_neg = {};".format(neg_expr))
    lines.append("  wire signed [TD_ACC-1:0] t_qprime_acc = $signed(t_qprime_pos) - $signed(t_qprime_neg);")
    lines.append("  wire [T_D_BITS-1:0] t_qprime = t_qprime_acc[T_D_BITS-1:0];")
    lines.append("  wire [WIDTH-1:0] m = t_qprime[WIDTH-1:0];")
    lines.append("")

    # mult_n pos/neg
    lines.append("  // m * q using {} decomposition".format(mode))
    lines.append("  localparam integer MN_ACC = MULT_BITS + 32;")
    qpos_expr = build_pos_expr("m", q_pos, "MN_ACC", "WIDTH")
    qneg_expr = build_pos_expr("m", q_neg, "MN_ACC", "WIDTH")
    lines.append("  wire [MN_ACC-1:0] multn_pos = {};".format(qpos_expr))
    lines.append("  wire [MN_ACC-1:0] multn_neg = {};".format(qneg_expr))
    lines.append("  wire signed [MN_ACC-1:0] multn_acc = $signed(multn_pos) - $signed(multn_neg);")
    lines.append("  wire [MULT_BITS-1:0] mult_n = multn_acc[MULT_BITS-1:0];")
    lines.append("")

    # sum and u
    lines.append("  // sum and reduction")
    lines.append("  wire [SUM_BITS-1:0] sum_temp = {{(SUM_BITS-T_BITS){{1'b0}}}, t_reg} + {{(SUM_BITS-MULT_BITS){{1'b0}}}, mult_n};")
    lines.append("  wire [U_BITS-1:0] u = sum_temp >> WIDTH;")
    lines.append("")

    # canonicalization wires at module scope
    lines.append("  // safe canonicalization (module-scope wires)")
    lines.append("  wire [U_BITS-1:0] q_ext  = {{(U_BITS-Q_BITS){{1'b0}}}, Q};")
    lines.append("  wire [U_BITS-1:0] u_ext  = u;")
    lines.append("  wire [U_BITS-1:0] u_sub  = u_ext - q_ext;")
    lines.append("  wire               u_geqQ = (u_ext >= q_ext);")
    lines.append("  wire [U_BITS-1:0] u_canon = u_geqQ ? u_sub : u_ext;")
    lines.append("")

    # FSM
    lines.append("  // FSM")
    lines.append("  reg [1:0] state;")
    lines.append("  localparam IDLE=0, MUL=1, COMPUTE=2;")
    lines.append("")
    lines.append("  always @(posedge clk or posedge rst) begin")
    lines.append("    if (rst) begin")
    if (a_const is None) or (b_const is None):
        lines.append("      mul_acc <= 0; idx <= 0; t_reg <= 0;")
    lines.append("      result <= 0; done <= 0; state <= IDLE;")
    lines.append("    end else begin")
    lines.append("      case (state)")
    lines.append("        IDLE: begin")
    lines.append("          done <= 0;")
    if (a_const is None) or (b_const is None):
        lines.append("          if (start) begin mul_acc <= 0; idx <= 0; state <= MUL; end")
    else:
        lines.append("          if (start) state <= COMPUTE;")
    lines.append("        end")
    if (a_const is None) or (b_const is None):
        lines.append("        MUL: begin")
        # careful with brace stringsâ€”these are literal Verilog snippets
        lines.append("          if (b[idx]) mul_acc <= mul_acc + ({{(T_BITS-WIDTH){1'b0}}, a} << idx);")
        lines.append("          if (idx == WIDTH-1) begin t_reg <= mul_acc; state <= COMPUTE; end")
        lines.append("          else idx <= idx + 1;")
        lines.append("        end")
    lines.append("        COMPUTE: begin")
    lines.append("          // write final result (slice down to WIDTH bits)")
    lines.append("          result <= u_canon[WIDTH-1:0];")
    lines.append("          done <= 1;")
    lines.append("          state <= IDLE;")
    lines.append("        end")
    lines.append("        default: state <= IDLE;")
    lines.append("      endcase")
    lines.append("    end")
    lines.append("  end")
    lines.append("")
    lines.append("endmodule")
    lines.append("")

    verilog_text = "\n".join(lines)

    # write to file
    with open(out_filename, "w") as f:
        f.write(verilog_text)

    # Dry-run info if constants provided
    dry_msg = ""
    if (a_const is not None) and (b_const is not None):
        a = a_const % q
        b = b_const % q
        t = a_const * b_const
        m_calc = (t * q_prime) & (R - 1)
        temp = t + m_calc * q
        u_calc = temp >> WIDTH
        if u_calc >= q:
            u_calc -= q
        normal = (u_calc * R_mod_q) % q
        dry_msg = (
            "DRY RUN:\n"
            " a = {}\n".format(a_const) +
            " b = {}\n".format(b_const) +
            " t = {}\n".format(t) +
            " q' = {}\n".format(q_prime) +
            " (t*q') = {}\n".format(t * q_prime) +
            " m = (t*q') mod R = {}\n".format(m_calc) +
            " temp = t + m*q = {}\n".format(temp) +
            " u = temp >> {} = {}\n".format(WIDTH, u_calc) +
            " montgomery-domain u = {}\n".format(u_calc) +
            " normal (u * (R % q)) % q = {}\n".format(normal)
        )

    return verilog_text, out_filename, dry_msg


# -------------------------
# CLI
# -------------------------
if __name__ == "__main__":
    print("KRED Montgomery Verilog generator")
    q = int(input("Enter prime modulus q (e.g. 9223372036855300097): ").strip())
    mode = input("Mode ('csd' or 'binary') [csd]: ").strip().lower() or "csd"

    a = int(input("Enter a (decimal): ").strip())
    b = int(input("Enter b (decimal): ").strip())


    verilog_text, fname, dry = generate_verilog(q, mode=mode, a_const=a, b_const=b)
    print("Wrote", fname)
    if dry:
        print(dry)

